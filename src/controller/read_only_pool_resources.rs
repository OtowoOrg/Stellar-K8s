//! Kubernetes resource builders for ReadOnlyPool
//!
//! This module creates and manages the underlying Kubernetes resources
//! (Deployments, Services, PVCs, ConfigMaps) for ReadOnlyPool.

use std::collections::BTreeMap;

use k8s_openapi::api::apps::v1::{Deployment, DeploymentSpec};
use k8s_openapi::api::core::v1::{
    ConfigMap, Container, ContainerPort, EnvVar, PodSpec, PodTemplateSpec,
    ResourceRequirements as K8sResources, Service, ServicePort, ServiceSpec, Volume, VolumeMount,
};
use k8s_openapi::apimachinery::pkg::api::resource::Quantity;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::{LabelSelector, ObjectMeta, OwnerReference};
use kube::api::{Api, Patch, PatchParams};
use kube::{Client, ResourceExt};
use tracing::{info, instrument};

use crate::crd::ReadOnlyPool;
use crate::error::Result;

/// Get the standard labels for a ReadOnlyPool's resources
fn standard_labels(pool: &ReadOnlyPool) -> BTreeMap<String, String> {
    let mut labels = BTreeMap::new();
    labels.insert(
        "app.kubernetes.io/name".to_string(),
        "readonly-pool".to_string(),
    );
    labels.insert("app.kubernetes.io/instance".to_string(), pool.name_any());
    labels.insert(
        "app.kubernetes.io/component".to_string(),
        "readonly-node".to_string(),
    );
    labels.insert(
        "app.kubernetes.io/managed-by".to_string(),
        "stellar-operator".to_string(),
    );
    labels.insert("stellar.org/pool-type".to_string(), "readonly".to_string());
    labels
}

/// Create an OwnerReference for garbage collection
fn owner_reference(pool: &ReadOnlyPool) -> OwnerReference {
    OwnerReference {
        api_version: "stellar.org/v1alpha1".to_string(),
        kind: "ReadOnlyPool".to_string(),
        name: pool.name_any(),
        uid: pool.metadata.uid.clone().unwrap_or_default(),
        controller: Some(true),
        block_owner_deletion: Some(true),
    }
}

/// Build the resource name for a given component
fn resource_name(pool: &ReadOnlyPool, suffix: &str) -> String {
    format!("{}-{}", pool.name_any(), suffix)
}

// ============================================================================
// PersistentVolumeClaim
// ============================================================================

/// Ensure a PersistentVolumeClaim exists for each pod in the pool
/// Note: For read-only pools, we use volumeClaimTemplates in StatefulSet
/// or individual PVCs per pod. For simplicity, we'll use individual PVCs.
#[allow(clippy::unnecessary_wraps, clippy::unused_async)]
#[instrument(skip(_client, _pool))]
pub async fn ensure_pvcs(_client: &Client, _pool: &ReadOnlyPool) -> Result<()> {
    // For read-only pools, we'll create PVCs on-demand as pods are created
    // The Deployment will use volumeClaimTemplates or we'll create PVCs dynamically
    // For now, we'll skip this and let the Deployment handle it
    Ok(())
}

// ============================================================================
// ConfigMap
// ============================================================================

/// Ensure a ConfigMap exists with node configuration
#[instrument(skip(client, pool), fields(name = %pool.name_any(), namespace = pool.namespace()))]
pub async fn ensure_config_map(client: &Client, pool: &ReadOnlyPool) -> Result<()> {
    let namespace = pool.namespace().unwrap_or_else(|| "default".to_string());
    let api: Api<ConfigMap> = Api::namespaced(client.clone(), &namespace);
    let name = resource_name(pool, "config");

    let cm = build_config_map(pool);

    let patch = Patch::Apply(&cm);
    api.patch(
        &name,
        &PatchParams::apply("stellar-operator").force(),
        &patch,
    )
    .await?;

    Ok(())
}

fn build_config_map(pool: &ReadOnlyPool) -> ConfigMap {
    let labels = standard_labels(pool);
    let name = resource_name(pool, "config");

    let mut data = BTreeMap::new();

    // Build stellar-core.cfg
    let mut config = format!(
        r#"# Stellar Core Configuration for Read-Only Pool
# Generated by stellar-operator

NETWORK_PASSPHRASE="{}"

# Database configuration (read-only nodes typically use SQLite or external DB)
DATABASE="sqlite3://stellar.db"

# History archive configuration
HISTORY.cur1="{}"
"#,
        pool.spec.network.passphrase(),
        pool.spec
            .history_archive_urls
            .first()
            .cloned()
            .unwrap_or_default()
    );

    // Add additional history archive URLs
    for (idx, url) in pool.spec.history_archive_urls.iter().enumerate().skip(1) {
        config.push_str(&format!("HISTORY.cur{}={}\n", idx + 1, url));
    }

    // Add core config override if provided
    if let Some(override_config) = &pool.spec.core_config_override {
        config.push_str("\n# Custom configuration override\n");
        config.push_str(override_config);
    }

    data.insert("stellar-core.cfg".to_string(), config);

    ConfigMap {
        metadata: ObjectMeta {
            name: Some(name),
            namespace: pool.namespace(),
            labels: Some(labels),
            owner_references: Some(vec![owner_reference(pool)]),
            ..Default::default()
        },
        data: Some(data),
        ..Default::default()
    }
}

// ============================================================================
// Deployment
// ============================================================================

/// Ensure a Deployment exists for the pool
#[instrument(skip(client, pool), fields(name = %pool.name_any(), namespace = pool.namespace()))]
pub async fn ensure_deployment(client: &Client, pool: &ReadOnlyPool) -> Result<()> {
    let namespace = pool.namespace().unwrap_or_else(|| "default".to_string());
    let api: Api<Deployment> = Api::namespaced(client.clone(), &namespace);
    let name = pool.name_any();

    let deployment = build_deployment(pool);

    let patch = Patch::Apply(&deployment);
    api.patch(
        &name,
        &PatchParams::apply("stellar-operator").force(),
        &patch,
    )
    .await?;

    info!("Deployment {} ensured", name);
    Ok(())
}

fn build_deployment(pool: &ReadOnlyPool) -> Deployment {
    let labels = standard_labels(pool);
    let name = pool.name_any();

    // Build container
    let env = vec![
        EnvVar {
            name: "NETWORK_PASSPHRASE".to_string(),
            value: Some(pool.spec.network.passphrase().to_string()),
            ..Default::default()
        },
        EnvVar {
            name: "STELLAR_CORE_CONFIG_PATH".to_string(),
            value: Some("/etc/stellar-core/stellar-core.cfg".to_string()),
            ..Default::default()
        },
    ];

    let container = Container {
        name: "stellar-core".to_string(),
        image: Some(pool.spec.container_image()),
        ports: Some(vec![
            ContainerPort {
                name: Some("peer".to_string()),
                container_port: 11625,
                protocol: Some("TCP".to_string()),
                ..Default::default()
            },
            ContainerPort {
                name: Some("http".to_string()),
                container_port: 11626,
                protocol: Some("TCP".to_string()),
                ..Default::default()
            },
        ]),
        env: Some(env),
        resources: Some(K8sResources {
            requests: Some({
                let mut reqs = BTreeMap::new();
                reqs.insert("cpu".to_string(), Quantity(pool.spec.resources.requests.cpu.clone()));
                reqs.insert(
                    "memory".to_string(),
                    Quantity(pool.spec.resources.requests.memory.clone()),
                );
                reqs
            }),
            limits: Some({
                let mut lims = BTreeMap::new();
                lims.insert("cpu".to_string(), Quantity(pool.spec.resources.limits.cpu.clone()));
                lims.insert(
                    "memory".to_string(),
                    Quantity(pool.spec.resources.limits.memory.clone()),
                );
                lims
            }),
            ..Default::default()
        }),
        volume_mounts: Some(vec![
            VolumeMount {
                name: "config".to_string(),
                mount_path: "/etc/stellar-core".to_string(),
                read_only: Some(true),
                ..Default::default()
            },
            VolumeMount {
                name: "data".to_string(),
                mount_path: "/var/lib/stellar-core".to_string(),
                ..Default::default()
            },
        ]),
        ..Default::default()
    };

    Deployment {
        metadata: ObjectMeta {
            name: Some(name),
            namespace: pool.namespace(),
            labels: Some(labels.clone()),
            owner_references: Some(vec![owner_reference(pool)]),
            ..Default::default()
        },
        spec: Some(DeploymentSpec {
            replicas: Some(pool.spec.target_replicas),
            selector: LabelSelector {
                match_labels: Some(labels.clone()),
                ..Default::default()
            },
            template: PodTemplateSpec {
                metadata: Some(ObjectMeta {
                    labels: Some(labels),
                    ..Default::default()
                }),
                spec: Some(PodSpec {
                    containers: vec![container],
                    volumes: Some(vec![
                        Volume {
                            name: "config".to_string(),
                            config_map: Some(k8s_openapi::api::core::v1::ConfigMapVolumeSource {
                                name: Some(resource_name(pool, "config")),
                                ..Default::default()
                            }),
                            ..Default::default()
                        },
                        Volume {
                            name: "data".to_string(),
                            persistent_volume_claim: Some(
                                k8s_openapi::api::core::v1::PersistentVolumeClaimVolumeSource {
                                    claim_name: format!("{}-data", pool.name_any()),
                                    read_only: Some(false),
                                },
                            ),
                            ..Default::default()
                        },
                    ]),
                    ..Default::default()
                }),
            },
            ..Default::default()
        }),
        status: None,
    }
}

// ============================================================================
// Service
// ============================================================================

/// Ensure a Service exists for the pool
#[instrument(skip(client, pool), fields(name = %pool.name_any(), namespace = pool.namespace()))]
pub async fn ensure_service(client: &Client, pool: &ReadOnlyPool) -> Result<()> {
    let namespace = pool.namespace().unwrap_or_else(|| "default".to_string());
    let api: Api<Service> = Api::namespaced(client.clone(), &namespace);
    let name = pool.name_any();

    let service = build_service(pool);

    let patch = Patch::Apply(&service);
    api.patch(
        &name,
        &PatchParams::apply("stellar-operator").force(),
        &patch,
    )
    .await?;

    info!("Service {} ensured", name);
    Ok(())
}

fn build_service(pool: &ReadOnlyPool) -> Service {
    let labels = standard_labels(pool);
    let name = pool.name_any();

    Service {
        metadata: ObjectMeta {
            name: Some(name),
            namespace: pool.namespace(),
            labels: Some(labels.clone()),
            owner_references: Some(vec![owner_reference(pool)]),
            ..Default::default()
        },
        spec: Some(ServiceSpec {
            selector: Some(labels),
            ports: Some(vec![
                ServicePort {
                    name: Some("peer".to_string()),
                    port: 11625,
                    target_port: Some(k8s_openapi::apimachinery::pkg::util::intstr::IntOrString::Int(11625)),
                    protocol: Some("TCP".to_string()),
                    ..Default::default()
                },
                ServicePort {
                    name: Some("http".to_string()),
                    port: 11626,
                    target_port: Some(k8s_openapi::apimachinery::pkg::util::intstr::IntOrString::Int(11626)),
                    protocol: Some("TCP".to_string()),
                    ..Default::default()
                },
            ]),
            ..Default::default()
        }),
        status: None,
    }
}
